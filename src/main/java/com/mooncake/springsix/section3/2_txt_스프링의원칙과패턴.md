원칙과 패턴

(1) 개방 폐쇄 원칙 (OCP)
> 클래스/모듈은 확정 열려 변경 닫혀야 함
> 변화: 어떤 클래스는 클래스 기능 확장시, 클래스 코드는 변경되면 안된다
> 가령, PaymentService 의 prepare 함수는 "어떻게 환율을 가져올 것인가?" 에 대해서 기능을 확장시킬 수 있다 (PaymentService 는 수정 없이!)
>> OCP 가 잘 적용된 예시


(2) 높은 응집도와 낮은 결합도 (Coherence / Coupling)
> 응집도 높다 : 하나의 모듈 / 클래스가 하나의 관심사 / 책임에 집중되어 있다는 뜻
>> 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다 (단점 같지만, 부분이 적다면 다른 곳에서 문제가 없는지 검증이 필요함)
>> 변화가 일어날 때 전체가 한번에 바뀌면 (ex: 환율 가져오던 방식을 다른 방식으로 바꿈), 외부에선 검증하기가 쉽다는 것
> 결합도 : 두 개 이상의 모듈 / 클래스가 연결이 되어 있어서 결합도는 존재하지만, 느슨한 형태를 유지해야 한다
> (수정시 바뀌는 정도 = 결합도) -> 적어야 함!


(3) 전략 패턴
> 자신의 기능에 대해서, 필요에 따라 변경이 필요한 알고리즘을 Interface 를 통해 외부와 분리.
> PaymentService 가 어떤 기능을 수행하기 위해 (환율 가져오기) interface 를 구현. (RateProvider interface) 
> 단, 우리가 한 건 Runtime 에 여러가지 교체가 이루어지고 그런건 아님 (전형적인 건 아님) - Client 에서 선택할 수 있게 구현해야 할 때 등


sort() 예시
> integer 는 기본적으로 된다
> String 을 정렬할 때, 우리가 원하는 방식을 넣고 싶다면, Comparator 라는 Interface 를 사용하면 된다 (전략 패턴이 잘 적용된 예시) 
> 기능을 바꾸기 위해서 새로운 Class Object 를 정의, 여기선 익명클래스로 간단히 적용해볼 수 있다 ( Comparator 는 이런 방식으로 많이 사용 함 ) 
> new Comparator<String> (){ compare(String o1, String o2) return o1.length() - o2.length();}
>> 이렇게 길이를 가지고 비교를 해줄 수 있도록 변경 가능. 람다 적용도 가능


(4) 제어의 역전 (IoC) 
> 제어권 이전을 통한 제어관계 역전 (Framework 동작 원리), 내가 이해한게 맞음. 내 코드를 호출해야 함
> 아 아님. Spring 에서 말하는 IoC 는 일반적인 IoC와는 다른 부분 (훨씬 inner 하게, interface 연계 부분이네!!) 
> Spring 에서의 IoC 는 쪼끔 다르긴 하다고 함
>> "제어권이 누구한테 있었고, 어디로 이전되었는가를 느껴야 한다"
>> 처음에는 어떤 ExRateProvider 를 이용할 것인지 PaymentService 측에서 정의되어서 결정을 했다 (직접적으로 선언) 
>> 나중에는 역할체를 PaymentService 에서 사용하고, 구현체는 Client 에서 제어할 수 있도록 하였다. (제어권이 이전됨) : 이것도 제어의 역전


** Spring 을 사용한다는 것 
> 이런 설계 원칙 / 디자인 패턴들이 우리 코드 안에 잘 녹아져 있어서, 우리 코드의 품질을 높이고, 유지보수성을 뛰어나게 해줌
> 클린한 코드를 써나갈 수 있도록 도움을 계속 받을 수 있다.
> 지금까진  Spring 없이 코드를 짰다. 이제 Spring 이 들어오면서 어떻게 바뀌는지 살펴본다.

<br>
----------- 
<br>
스프링 컨테이너 (IoC / DI 컨테이너)
> 스프링의 기술 중 가장 핵심에 있고 기반이 되는 기술

![Spring 이 제공해주는 Bean Factory 로 대체된 모습 ](/src/main/resources/image/section3_9.png)

> MainClient.java 의 V8 확인
> BeanFactory 와 MyObjectFactory Configuration 을 활용해서 유연한 확장을 확인할 수 있었다
> (MyObjectFactory 의 역할체 변경) - 여기서 DI 가 발생한다
> 이 BeanFactory 가 Spring 이다 라고 생각해도 과언이 아닐 정도로 중요한 부분
>> spring 이 객체지향 설계 원칙을 잘 준수한 app 을 만들 수 있도록 도와준다

> Container 에 가지고 있다가 객체들을 보관하고 있는 모습을 확인할 수 있었다
>> 많은 요청에 대응하여 초당 천건 객체를 생성하고 그러면 부하가 있을 수 밖에 없음 (Container 에 미리 보관하는 이유)
>> 사용하는 스레드 Stack 에 쌓여서 생성되기 때문에 각기 다른 인스턴스를 제어할 수 있음
>> Spring 의 가장 큰 정체성은 Container 이며, 단순 보관이 아닌, 연관 관계까지 다 설정된 상태로 보관하는 DI 지원 컨테이너이다
> 
# 다시 보는 개방 폐쇄 원칙

- 템플릿을 다루기에 앞서 OCP 를 다시 한 번 봐야 한다
- OCP : 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다는 원칙
- 정석적인 OCP 와는 또 다른 접근이 필요하기도 하다
- 개발을 하다 보면, 어떤 기능적인 부분은 계속 변경/확장의 성질을 가짐. 어떤 부분은 거의 변하지 않는 성질을 가지기도 한다.
- 이 부분들을 더 유연하게 설계하기 위함 (변화의 특성이 다른 부분들을 구분 & 목적과 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 구조)

<br>

- 기존에 OCP 를 지켜서 개발했던 것 (PaymentService 와 ExRateProvider - V6 참고)
- 동작하는 App 에서 OCP 를 유지시키기 위해선 DI를 사용하고, Spring Container 의 도움을 받기도 하였음

<br>

# 템플릿 콜백 패턴

- 변경이 일어나지 않으며 일정한 패턴으로 유지되는 부분과 자유롭게 변경되는 성질을 가진 부분을 분리하는 디자인 패턴 → OCP 를 효과적으로 지키는 방법
- 일정한 부분을 템플릿이라 하고, 자유롭게 변경되는 성질 부분을 콜백이라 한다

<br>

# 우선 WebApiExRateProvider 리팩토링

- 리펙토링 → 기존 코드 결과의 변경 없이 구조를 개선하는 작업 (리펙토링 하는 습관을 가지라고 하신다)
- 리펙토링된 코드 = WebApiExRateProviderV2

<br>

# 템플릿 패턴 적용1 - 변하는 코드 분리하기

- WebApiExRateProviderV2 에서 나뉘어진 3가지 구조를 봤을 때, 1번은 잘 바뀌지 않을 것 같고, 2,3번은 충분히 바뀔 수도 있다.
- 2번 ex: HttpUrlConnection 을 안쓰기로 함. BufferedReader 를 안쓰기로 함. 동기 통신을 안쓰기로 함 등
- 3번 ex: 만약 Open API 가 종료되어 다른 API 사용. 기존 Open API 에서 응답 형식 변경 등

- Template
    - 템플릿은 프로그래밍에선 고정된 틀 안에서 "바꿀 수 있는 부분"을 바꿀 수 있도록 만들어진 오브젝트
    - 템플릿 메소드 패턴에서 말하는 템플릿이긴 하지만 또 약간 다르다고 함
    - 템플릿 메소드 패턴은 틀이 Super Class, 바뀌는 부분이 Sub Class 의 Method 로 구현

- 1,2,3 번을 각각 뽑아낸 것이 V3라고 할 수 있다 (method 이름 유의)

<br>

# ApiExecutor 의 도입

- 위 상황만으로는 그냥 함수 추출한 것이기 때문에 재사용성이 우수한게 아님
- 변경 가능한 부분을 interface 로 하여, Dynamic 한 구현체 변경이 가능하도록 한다


<br>

# 콜백과 템플릿/콜백 패턴

- 콜백이란
    - ApiExecutor 인터페이스를 콜백으로 만들건데, 보통 Method 주입 (Method Injection 과 함께 나옴)
    - Callback 은 프로그래밍에서 오랫동안 사용된 것 (강의에서 콜백 페이지에 있는 설명은 진짜 뭔소린지 전혀 모르겠음.. 말을 쓸데없이 어렵게 해놓음)
    - ✅ 콜백(callback)이란? - "나중에 호출해달라고 전달해두는 함수"
    - 콜백은 "나중에 호출해줘" 라고 하면서 하나의 메소드를 가진 interface 나 람다 함수를 던지는 것을 말한다.
    - "단일함수 인터페이스를 콜백으로 많이 사용하고, 단일함수 인터페이스는 람다로 대체가 가능하다" 로 연결되는게 맞다

<br>

- 템플릿 콜백
    - 전략 패턴의 특수한 케이스 → 템플릿이 Concrete 한 컨텍스트이고, Callback 이 전략이다. (해당 경우 메소드 하나만 가진 전략 인터페이스 사용)
    - 메소드 주입 (Method Injection) 을 알아야 하는데, 예시는 다음과 같음
    - Worker 에게 할 일(interface) 이 파라미터로 전달되어 지정된다 → 이를 메소드 호출 주입이라고 함.
      '
<pre>```
interface Callback {
void call();
}

class Worker {
void doSomething(Callback callback) {
System.out.println("일을 처리 중...");
callback.call();
}
}

// 사용
Worker worker = new Worker();
worker.doSomething(new Callback() {
public void call() {
System.out.println("일이 끝난 후 실행되는 콜백!");
}
});
```</pre>

<br>

- ApiExecutor 로 인터페이스 분리, 그리고 이에 대한 콜백 템플릿 적용은 intf 패키지와 V4를 보면 된다
- Client 가 직접 수행할 "전략"을 템플릿을 수행하는 함수에게 전달하는 방식 (템플릿/콜백은 조합이 정말 잘 맞긴 할 것 같다)
    - 템플릿 패턴 자체는 "고정된 흐름 제공, 일부 동작을 사용자에게 맡긴다" 에서 사용되는 패턴이므로, "일부 동작"을 정의할 때 콜백으로 적합
    - 그리고 "그 동작만 전달" 하기 위해 단일 함수 인터페이스가 사용되고, 단일 함수 인터페이스는 람다로 대체가 되기 때문에 람다로도 많이 사용되는 걸로 연결되는 느낌

<br>

![템플릿 콜백 패턴 호출 순서](/src/main/resources/image/section5_5.png)

- 클라는 템플릿을 호출하면서 수행할 "전략"부분을 정의해서 (Callback) 템플릿을 호출하면서 같이 넘긴다
- 템플릿은 실행되는 중간에 Callback 을 통해 "전략" 부분을 수행한다
    - 그림이 저렇게 되어 있는 이유는 일반적으로 Client 가 참조하고 있는 Callback intf 를 넘기기 때문
    - 참고로 두개 이상의 함수를 가지고 있는 콜백을 만들어서 넘겨주는 것도 당연히 가능

